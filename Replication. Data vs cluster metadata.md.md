 Чтобы делать это нужно в кластере приходить к консенсусу по вопросу “какое значение в логе будет следующим?”. Для этого используются алгоритмы консенсуса. Для того, чтобы с одной стороны не потерять данные при падении лидера, с другой - не реплицировать синхронно на все ноды, используются пересекающиеся кворумы(обычно берется большинство нод): кворум на синхронную репликацию и кворум при выборе нового лидера. В итоге гарантируется пересечение этих кворумов и хотя бы одна нода будет содержать максимально актуальные данные после падения лидера. Недостатком такого подхода является большая избыточность: чтобы застраховаться от падения всего одной ноды, нужно иметь кластер из 3 нод. От падения двух нод - кластер из 5ти нод. Именно поэтому majority используется в основном для синронизации мета информации, конфигурации кластера, а не для синхронизации основных данных. Именно так и поступает ZooKeeper, когда реплицирует свои данные(метаданные кластера Kafka). Объем метаданных гораздо меньше, частота ниже, важность этих данных гораздо выше для работы кластера(грубо говоря сообщения в случае глобального краша можно потерять и продолжить работу. А вот если сломались метаданные, то больше будет проблем).
Для репликации основных данных Kafka использует знание о списке in-synс replicas (ISR). Этот список хранится в Zookeeper. При падении лидера новый может быть выбран только из ISR. При записи лидер для комита должен записать на все ISR, но при этом для работы достаточно по сути всего одной ноды из ISR. Т.е. кластер из f+1 нод переживает f падений. То же значение падений при использовании majority обеспечивается общим кол-во нод 2f+1. Топик можно скофигурировать минимальным кол-вом ISR, чтобы запись была возможной. Т.е. если продьюсер публикует сообщение с настройкой all (т.е. сообщение будет считаться закомиченным если оно реплицируется на все ISR), то публикация будет успешной, если в ISR не меньше сконфигурированного минимума. Т.о. эта настройка приближает ISR к majority quorum. Тут вступает в дело компромисс durability(устанавливаем побольше минимальный объем ISR, чтобы не потерять данные) vs availability(работаем до последней рабочей  in-sync реплики).
Отличие ISR от majority quorum в том, что использование ISR отвязывает требуемое кол-во ответов, чтобы запись считалась committed, от общего кол-ва реплик. Плюс в этом подходе не достаточно любого большинства, а нужно дождаться определенного набора реплик. Это потенциально увеличивает latency, потому что запись может быть долгой из-за медленных реплик в ISR или в случае падения нужно дождаться его опознавания и исключения этой реплики из ISR.