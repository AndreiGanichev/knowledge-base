---
date: 2023-11-03
---
# Garbage collector

## Алгоритм cборки

1. Остановка выполняющихся потоков
2. Маркировка: всем объектам в куче проставляется индекс блока синхронизации 0
3. Перебор корней (переменных ссылочного типа) с рекурсивным перебором их полей. Для об'ектов, на которые есть ссылка проставляется индекс блока синхронизации 1.
4. Удаляются об'екты с индексом блока синхронизации 0.
5. Пережившие уборку мусора об'екты сжимаются для обеспечения непрерывной области занятой и свободной памяти.

Уборка мусора начинается в 0м поколении, когда оно достигает порогового значения. GC начинает чистку в поколении 1, когда оно превышает установленный порог. А точнее в текущую уборку GC переместил из 0го поколения в 1е и оно превысило порог. В следующую уборку GC почистит и 0е, и 1е поколения.

Пороги для поколений могут меняться, потому что GC подстраивается под текущие условия: если создаётся много маложивущих об'ектов, то размер 0го поколения устанавливается небольшой и уборки частые и эффективные(много места освобождается) и т.п.

Для больших об'ектов (>85кБ) память выделяется в отдельной части адресного пространства (large object heap). Они по умолчанию отросятся ко 2му поколению. Чаще всего это строки, например json.

Если понятно, что очистить необходимый размер памяти не получается, то GC проводит полную очистку и потом выбрасывает OutOfMemoryException.

Уборка мусора начинается, когда:

1. Размер 0го поколения превышает порог
2. Вызов `System.GC.Collect()`. Позволяет указать в каких поколениях убраться и другие параметры.
3. Windows сообщает о нехватки памяти
4. Выгрузка домена приложения
5. Завершение работы CLR

Для "ручного" управления временем жизни объекта можно использовать таблицу GC-дескрипторов. Каждая запись в таблице содержит ссылку на объект и флаг `GCHandleType`. Пример использования: если необходимо передать кусок управляемой памяти в пользование неуправляемому коду, то можно установить флаг Pinned и тогда память не будет освобождена и перемещена при сжатии. Класс `WeakReference<T>` это удобная для использования обертка для GCHandle.

## Причины утечки памяти

1. объект не нужен, но не удалена его подписка на "живое" событие
2. Статическое поле содержит коллекцию об'ектов, в которую добавляются элементы. Это поле принадлежит об'екту-типу и будет жить пока приложение не завершит работу. А значит будут жить и ссылки на элементы коллекции.

## Режимы

Различают режимы уборки: режим рабочей станции(workstation) и режим сервера(server). В первом случа CLR предполагает, что на машине запущены и другие пользовательские приложения и не включает уборку на полную(поток, которые выполняет сборку имеет *нормальный* приоритет), чтобы они не тормозили. В случае server gc поток сборки имеет высокий приоритет и сборка может потреблять больше ресурсов.

В случае *server gc* для каждого ядра создается свой heap:

> A heap and a dedicated thread to perform garbage collection are provided for each logical CPU. [Doc](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/workstation-server-gc#server-gc)

Также различают параллельный(concurrent, background) и непараллельный(non-concurrent) режимы. В первом случае отдельный поток во время работы приложения занимается пометкой недостижимых объектов, а значит ускоряет сам процесс уборки.

## Неуправляемые ресурсы

Бывают большие по об'ему системные ресурсы, которые представлены в управляемой памяти маленькими объектами. Например, растровое изображение. GC ориентируется на управляемый объект и может и не догадываться о реальном об'еме занимаемой памяти. В случае, когда создано много таких объектов это может стать проблемой, потому что в управляемой то памяти все хорошо, а на самом деле удерживается ещё много системной. Есть два способа дать понять GCу с каким реальным объемом он имеет дело. С помощью статических методов AddMemoryPressure, RemoveMemoryPressure из класса-обертки большого системного ресурса можно указать GCу объем реально занимаемой памяти(пусть и неуправляемой). Плюс есть класс HandleCollector, используя который можно помочь GCу следить за созданием объектов, управляющих большими системными ресурсами.

## Финализаторы

1. С управляемым ресурсом(памятью) прекрасно справляется GC без помощи со стороны разработчика. Но классы могут использовать системные ресурсы: файл, сетевое соединение, сокет, мьютекс и др. О них GC ничего не знает, поэтому и не сможет их освободить. Поэтому разработчик класса, использующего неуправляемые ресурсы должен позаботится об их освобождении до уборки объекта GCом. Для этой цели используются финализатор, который GC запускает для недостижимых финализируемых объектов после проведения уборки мусора. Поэтому финализируемые объекты переживают первую уборку и переходят в следующее поколение. Это не очень хорошо, потому что сразу получаем в 1м поколении недостижимые объекты. Ситуация ухудшается, если эти объекты имеют поля ссылочного типа, которые тоже переживут уборку. Из финализатора нельзя обращаться к другим финализируемым объектам, потому что их ресурсы уже могут быть освобождены. Но можно к обычным объектам. Статические методы тоже не стоит вызывать из финализаторов.

2. Для вызова финализатора CLR использует специальный высокоприоритетный поток.

3. Использование системных ресурсов напрямую, а значит необходимость в финализаторе лучше избегать. Для системных ресурсов лучше реализовать управляемую обертку, создав наследник от `SafeHandle`. Она возьмёт на себя заботу об освобождении ресурса, а с ней можно обращаться как с управляемым ресурсом.

4. Классы, позволяющие пользователю управлять жизненным циклом инкапсулированных системных ресурсов, реализуют интерфейс `IDisposable`. При этом гарантированное освобождение системных ресурсов возможно и без явного вызова метода Dispose. Рано или поздно оно все равно будет выполнено в финализаторе. Вызов Dispose позволяет вам управлять тем, когда это произойдёт. Вызов метода Dispose не удаляет объект из кучи, этим занимается GC. Вызывая метод Dispose мы сами говорим, что объект стал ненужным. При попытке после этого обратиться к его членам должно генерироваться `ObjectDisposedException`. Если класс использует поле типа, реализующего `IDisposable`, тот этот класс тоже должен реализовать `IDisposable` и в `Dispose()` вызвать соответствующий метод у поля. Так цепочка вызовов Dispose дойдёт до реализации `SafeHandle`, где непосредственно будет освобождён системный ресурс.

---

## Источники

1. [[CLR via C# book]]

## Ссылки

1. link
