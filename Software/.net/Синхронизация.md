---
date: 2023-11-03
---
# Синхронизация

**Цель** синхронизации- предотвратить повреждение общих данных при одновременном доступе к этим данным разных потоков. Причем потокобезопасность не обязательно обеспечивается за счет блокировок. Можно например использовать значимые типы, иммутабельность, потому что проблемы могут возникнуть только при записи, а читать то можно и параллельно.

Причины необходимости синхронизации:

1. более читабельный код: линейный, без использования callback: просто ждем и все, вместо того, чтобы продолжение оформить в виде callback
2. потоки привязаны к каким-то заданиям(проверка орфографии, форматирование и проч.). 
Рихтер пишет, что асинхронное программирование может быть альтернативой синхронизации потоков. Во-первых мы работаем с более абстрактной сущностью - Task, которая как раз представляет собой конкретную задачу. Во-вторых позволяет писать читабельный код(выглядит как синхронный). В-третьих оптимально использует потоки пула. Мы синхронизируем задачи, но не блокируем потоки.

Библиотека FCL **гарантирует безопасность в отношении потоков для всех статических методов**.

## Виды блокировок

1. пользовательского режима (user mode)
1. режима ядра (kernel mode)

Пользовательский режим работает очень быстро при отсутствии конкуренции за блокировку. Он характерен тем, что ОС ничего не знает об ожидании потоком блокировки, поток просто "работает в холостую"(livelock).

Режим ядра обеспечивает полноценную блокировку на уровне ОС она перестает планировать поток на исполнение(deadlock).

### User mode

Можно использовать для синхронизации потоков одного процесса.

1. `Volatile`. Ключевым словом можно пометить поле(статические и экземплярные, числовых типов, char, ссылочных типов), что обеспечивает:
    - атомарность записи или чтения
    - запись в него производится последней, чтение первым по сравнению с другими переменными(запрещает перестановку строк программы при оптимизации),
    - запрещается кэшировать его значение в регистрах процессора(любое чтение будет выполнено из памяти).
2. `Interlocked` предоставляет набор операций с гарантией их атомарности. Например используется метод Exchange, который присваивает указанной переменной переданное значение и возвращает старое значение переменной. Пусть переменная будет принимать значения 0 и 1. Будем считать, что при нуле блокировка свободна. Делаем попытку Exchange с новым значением 1, проверяем возвращенное старое значение. Если ноль, то блокировка была свободна, в теперь занята. Если единица, то блокировав была занята и Ее нужно ждать, например в цикле. С помощью Interlocked-паттерна (compare-and-swap) можно осуществлять довольно сложную синхронизацию.

### Kernel mode

Конструкции режима ядра могут быть использованы для создания приложений, которые в любой момент времени могут существовать только в одном экземпляре, синхронизации потоков разных процессов.

К **примитивным** конструкциям синхронизации относятся:

1. события(boolean)
1. семафоры(int32)
1. мьютексы

Событие с автосбросом эквивалентно семафору, у которого максимально значение счетчика 1, и мьютексу. Мьютекс более навороченный: знает какой поток им владеет, управляет рекурсивным счётчиком, указывающим сколько раз поток-владелец уже владел объектом. Автосброс события значит, что после освобождения блокировки ОС пропустит только один поток внутрь критической секции, а потом автоматически сбросит флаг в false. В ручных событиях такого нет, а управляется все непосредственно нашим кодом.

У них всех принцип работы такой(на примере мьютекса):
```csharp
lock.WaitOne();
//синхронизируемая операция
lock.ReleaseMutex();
```

#### Гибридные конструкции

`SemaphoreSlim, ManualyResetEventSlim, Monitor.`

Сочетают в себе лучшее от рассмотренных режимов: при отсутствии конкуренции не требую затратного обращения к ОС, а при блокировке по-настоящему блокируют поток.

Наиболее популярной конструкцией является `Monitor`. Он поддерживает взаимоисключающее блокирование с зацикливанием, владением потоком и рекурсией.
Monitor работает также как и вышеперечисленные конструкции режима ядра: имеет методы `Enter` и `Exit`, которые принимают(`object`) любой объект, расположенный в куче, в том числе объект-тип. Последнее возможно, если на статический метод повесить атрибут `MethodIml` со значение Synchronous. Упрощённый синтаксис - использование кл. слова lock. Компилятор оборачивает код в `try-finally`, где в последнем происходит снятие блокировки. Это кстати опасно, потому что неизвестно что успел поток наделать в критической секции, а мы даем теперь другому потоку доступ туда


CLR имеет массив блоков синхронизации. Каждый блок содержит: объект ядра, ид потока-владельца, счётчик рекурсии, счётчик ожидающих потоков. Каждый объект в куче имеет индекс блока синхронизации. При конструировании объектов этот индекс устанавливается в -1, что означает отсутствие блокировки на объекте. При вызове Monitor.Enter(someObj) CLR берет свободный блок синхронизации из массива и проставляет его индекс в индекс блока синхронизации объекта someObj. При вызове Monitor.Exit(someObj) CLR проверяет ожидает какой-то поток блок синхронизации объекта someObj. Если таких нет, в в индексе блока синхронизации someObj проставляется -1.
Теоретически в lock можно передавать this(так происходит если экземплярный метод пометить атрибутом MethodImpl со значением Synchronous). Но это приводит к созданию "открытой" блокировки, потому что любой код извне этого объекта, переданного по this, может взять этот же экземпляр и запросить блокировку. А  если пометить атрибутом статический метод, то заблокирован будет объект-тип.

Нельзя делать объектов блокировки:

1. Объект-представитель(маршалинг): блокируется не представитель, а сам представляемый им объект.
2. Объект-тип: если он загружен нейтрально по отношению к домену, до будет заблокирован во всех доменах
3. Строки: по причине интернирования есть вероятность в разных независимых местах обратиться к одной блокировке
4. Значимый тип: т.к. методы Monitor'a принимают object, то значимы тип упакуется, а значит каждый раз при попытке взять блокировку будет создаваться новый объект и фактически синхронизации не будет происходить.

Такой пример: код вошёл в блок try, но не добрался до взятия блокировки и упал с ошибкой. В блоке finally мы попытаемся снять невзятую блокировку. Для решения этой ситуации вводится переменная bool lockTaken, которая проверяется в finally перед снятием блокировки.

Также среди гибридных конструкций есть Barrier, который, например, обеспечивает синхронизацию потоков алгоритма("начинаем новую фазу алгоритма только когда все предыдущие, выполняемые параллельно, завершены"). Этот пример использования очень похож на логику работы метода WhenAll. И есть еще конструкция чтения/записи, которая позволяет параллельно читать, но блокирует при записи.

Блокировка с двойной проверкой используется при реализации *Singleton*: 

1. проверяем на null, чтобы избежать обращения к ОС для взятия блокировки
2. берем блокировку
3. проверяем на null, потому что вдруг на момент освобождения блокировки экземпляр уже создан

---

## Источники

1. [[CLR via C# book]]

## Ссылки

1. [[Threadsafe collections]]
