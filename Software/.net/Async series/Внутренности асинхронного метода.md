---
date: 2023-11-02
---
# Внутренности асинхронного метода

**Асинхронный метод** - метод, помеченный ключевым словом async.

Компилятор:

1. разбивает логику, размещенную в методе на части между await'ами
2. создает конечный автомат(КА) с методом ```MoveNext```, в котором размещает ```switch``` относительно состояния КА
3. каждая ветви ```switch```'а:
   содержит один из кусков логики исходного метода, заключенных между вызовами аснихронных методов с await. Меняет состояние КА, используя вспомогательные классы(```AsyncTaskMethodBuilder```, ```TaskAwaiter```) делает так, что после окончания асинхронной операции снова вызвался метод КА ```MoveNext```, что-то типа ```.ContinueWith(KA.MoveNext())```.

Особенности:

1. перед тем, как создать задачу-продолжение по итогам асинхронной операции, делается проверка, а не выполнена ли она.
2. если операция уже выполнена, то экономится ресурсы, потому что не выделяется (allocation) память в куче для boxing'a КА, который является структурой, а не ссылочным типом
3. т.к. используется вызов ```awaiter.GetResult()```, а не ```task.Wait()``` или ```task.Result```, то в случае исключений, выброшенных в ходе выполнения асинхронной операции, в вызывающий метод пробросится только первое. Тогда как ```task.Wait()``` или ```task.Result``` вернули бы ```AggregateException```.

Исходный код:

```csharp
    public async Task<decimal> GetStockPriceForAsync(string companyId)
    {
        await InitializeMapIfNeededAsync();
        _stockPrices.TryGetValue(companyId, out var result);
        return result;
    }
```

Схема работы:

![Внутренности асинхронного метода](img/Внутренности%20асинхронного%20метода_37-59.png)

```Execution Context``` содержит информацию, "об окружающей среде", такую как настройки безопасности, культурная среда и др., которая в синхронном однопоточном мире хранится в thread-local storage. Т.к. этот вариант невозможен при выполнении кода в разных потоках, то на помощь и приходит execution context, который сохраняет нужную информацию в рамках логической последовательности выполнения кода.

> ```AsyncLocal<T>``` data flows as part of ```ExecutionContext```. [ConfigureAwait FAQ](https://devblogs.microsoft.com/dotnet/configureawait-faq/)

Это работает, когда мы например вызываем ```Task.Run```, execution context текущего метода захватывается и хранится в получившейся задаче. Но в последовательности, показано на диаграмме есть два unsafe-метода, которые не поддерживают автоматический захват и сохранение execution context, поэтому этим "вручную" занимаются ```AsyncMethodBuilder``` и ```MoveNextRunner```.

```StateMachine``` содержит исходную логику метода, логику переключения между состояниями

```AsyncTaskMethodBuilder``` один на асинхронный метод и содержит в себе задачу, которую вернул асинхронный метод. Билдер управляет ее состоянием методами SetResult, SetException

```TaskAwaiter``` будет создаваться на каждый асинхронный вызов внутри рассматриваемого метода. Этот объект инкапсулирует в себе задачу и позволяет узнать ее статус и задать продолжение, которое будет вызвано после завершения.

---

## Источники

1. [Dissecting the async methods in c# by Sergey Tepliakov](https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/)

## Ссылки

1. link
