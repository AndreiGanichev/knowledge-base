---
date: 2023-11-03
---
# Threads, TPL

1. **Процесс** можно рассматривать как набор ресурсов, например область в памяти, в которой он работает. **Поток** исполнения можно рассматривать как виртуальный(логический) процессор. Процесс - аквариум с ресурсами (водой, едой), а поток - рыбки, использующие эти ресурсы.

2. Создание процесса достаточно дорогостоящая операция, поэтому были введены более легковесные потоки. На каждый процесс как минимум один поток исполнения. Но поток тоже не бесплатный: для каждого выделяется структура в памяти(см. ниже), в ней только user-mode stack занимает 1 Мб в памяти.

3. Переключение физического процессора между потоками тоже достаточно затратно, плюс если эти потоки принадлежат разным процессам, то для выхода на полную мощность процессор должен сначала заполнить свой кэш значениями из памяти.

4. Процессы и потоки имеют свои приоритеты, в соответствии с которыми ОС производит переключение между потоками. Итоговый приоритет потока складывается из приоритета процесса в ОС и приоритета потока в процессе. Управляемые приложения не могут влиять на приоритет процесса, но могут на приоритет потока. При этом ОС резервирует для себя min(Idle) и max(Realtime) приоритеты процессов, а CLR - min(Idle) и max(Time-Critical. С таким запускается GC) приоритеты потоков.

5. Для работы с потоками используется класс System.Thread. Сначала создаём экземпляр потока, передав в него исполняемый метод. Start - запуск метода в потоке, Join - ожидание завершения выполнения метода в потоке. Поток CLR соответствует потоку в ОС.

6. Для повышения эффективности использования потоков нужно использовать пул потоков. Пул один на экземпляр CLR. Если хотим запустить операцию в потоке из пула, то ставим eе в очередь QueueUserWorkItem(WaitCallback callback). Дальше пул берет свободный или создаёт новый поток и запускает его. Потоки возвращённые в пул после определенного периода бездействия пробуждаются и самоуничтожаются. Можно установить ограничение на кол-во потоков в пуле, но не стоит это делать. В mapi, например, ставили ограничение примерное равное кол-ву ядер.

7. Потоки бывают фоновые и активные. Приложение не может завершить работу, если есть *активные* потоки, поэтому их нужно создавать с осторожностью. Потоки пула - *фоновые*.

8. Отмена выполнения потока производится связкой `CancellationTokenSouce` и `CancellationToken` (передаётся в метод для периодической проверки не запрошена ли отмена). Для токена можно зарегистрировать callback на случай отмены. Поддерживается отмена по тайм-ауту. Несколько Cts можно связать друг с другом и отмена этого комплексного источника произойдет при отмене любого из исходных. Если в процессе работы потока возникло исключение, то оно будет выброшено при вызове `Cancel()`. `CancellationToken.None` используется если метод требует передачи ct, но отмена нам не нужна никогда.

9. Используя пул потоков у нас нет возможности отследить факт завершения задания или получить его результат. Поэтому для удобства работы была введена более абстрактная сущность - `Task`. Это позволяет программистам думать более абстрактно, на уровне задач, которые решает приложение. А как эти задачи будут исполняться - забота диспетчера задач. Назначение потоку определенной задачи(не `Task`, а именно логической задачи типа проверки орфографии) Рихтер называет одной из причин необходимости синхронизации потоков. Используя `Task` мы синхронизируем задачи, а потоки при этом не зацикливаются и не блокируются.

10. `TaskFactory` позволяет создавать одинаково сконфигурированные задачи: `CTS, TaskScheduler, TaskCreationOptions, TaskContinuationOptions`.

11. Назначение `TaskScheduler` - обеспечить запуск задачи. Выделяют планировщик в пуле потоков и планировщик контекста синхронизации. В asp.net нет класса `SynchronizationContext`, потому что для выполнения запросов используются потоки пула и соответственно планировщик в пуле. А для десктопных приложений потоковая модель накладывает ограничения на обновление ui только в основном потоке приложения, в старом asp было ограничение на один поток на запрос.

12. Для поддержания отмены задания один и тот же токен должен быть: при создании таски, в самом методе, запускаемом асинхронно, и во вне, откуда инициируется отмена.

13. С помощью `TaskCreationOptions.AttachedToParent` можно создавать дочерние задачи. Родительская задача считается завершённой только после завершения всех дочерних. `TaskCreationOptions.LongRunning` предназначено для выполнения длительных задач и приводит к созданию потока **вне пула**. Планировщик задач считает, что если поток выполняется более 0,5 секунды, то он скорее всего часто блокируется(I/O или lock), а значит неэффективно использует ресурсы процессора. Поэтому планировщик создает новый поток, чтобы загрузить процессор. Чтобы избежать создания новых потоков и задержек, вызванных работой планировщика, используется флаг `LongRunning`.

14. Метод `ContinueWith()` для задачи можно вызывать несколько раз, тогда по её завершению все продолжения попадут в очередь пула

15. Метод `Task.Yield()` позволяет освободить и вернуть в пул текущий поток. При этом продолжение метода сразу же снова планируется для выполнения(добавляется в очередь задач для пула). Это актуально для долгоиграющей задачи, которая периодически вызывает метод и освобождает поток.

16. Возможность асинхронного поведения обеспечивают именно Tasks, потому что они предоставляют возможность отследить статус задачи и ее результат. Этого достаточно, чтобы писать асинхронный код, используя `ContinueWith`. `async/await` ничего нового не привносит, это просто синт. сахар, который добавляет удобства использования и получения читаемого асинхронного кода.

17. Устройства I/O имеют свои микропроцессоры и выполняют полученную задачу без участия CPU. Поэтому ОС не блокирует поток, который запросил I/O. Поток может вернуться в пул и заняться чем-то полезным.

18. Библиотека TPL DataFlow предназначена для упрощения параллельной обработки данных за счет того, что разработчику не приходится работать с низкоуровнемы конструкциями синхронизации потоков. Идея в том, что из различных блоков создается своего рода алгоритм, который не обязательно прямолинейный(pipes), но может содержать циклы. Каждый блок содержит один или два буфера(на входе и на выходе) и одну или две таски(одна проталкивает данные в следующий блок, другая выполняет полезную логику). Виды блоков(на что похожа их работа): BufferBlock(queue), ActionBlock(foreach), NullTarget(как discard в switch), TransformBlock(Select), TransformManyBlock(SelectMany). Серии статей раз и два по теме.

19. Использование класса `Parallel` даёт максимальный выигрыш при множестве элементов для обработки или когда обработка каждого элемента представляет собой длительную операцию. Метод For быстрее, чем ForEach.

Поток исполнения в ОС(windows) описывается структурой:

1. thread kernel object. Туда в частности windows выгружает контекст потока при снятии его с процессора
2. thread env block
3. user-mode stack. Это собственно стек потока
4. kernel-mode stack. При вызове системных функций сюда помещаются аргументы. А ОС соответственно читает их отсюда.

Используя System.Thread можно создать поток вне пула. Возможные причины:

1. долгая вычислительная операция(см. другой вариант создания - `TaskCreationOptions.LongRunning`)
2. необходимость управления приоритетом потока
3. необходимость иметь возможность прервать поток
То есть получается, когда нужно какой-то индивидуальный подход к потоку. А используя пул мы оперируем задачами, которые в итоге распределяет диспетчер на безликие рабочие лошадки-потоки из пула. И сами потоки фактически скрыты от программиста.

## Ограничение асинхронных ф-ий:

1. не может использоваться в catch, finally (неактуально с C#6), unsafe
2. не допускает ref, out параметров
3. использование с lock
    - это способ организовать deadlock
    - до await блокировку берет один поток, а после await уже может работать другой. А Lock отслеживает владение потоком

## Алгоритм работы рабочего потока пула

![Алгоритм работы пула потоков](img/Threads,%20TPL_15-04.png)

---

## Источники

1. [[CLR via C# book]]

## Ссылки

1. link
