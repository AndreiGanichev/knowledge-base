---
date: 2023-11-03
---
# Exceptions

1. `try` - операция, способная выбросить исключение; `catch` - логика восстановления после исключения или дополнительная логика перед пробросим исходного или нового исключения; `finally` - подчистка начатых в `try` операций: закрытие ресурсов, снятие блокировки и т.п. `try` должен быть связан хотя бы с одним блоком либо `catch`, либо `finally`, иначе он не имеет смысла.

1. Блок `finally` выполняется всегда! Есть исключения: прерывание потока функцией `TerminateThread` или методом `FailFast` класса `System.Enviroment`.

1. Если источником исключения являются блоки `catch` или `finally`, то CLR продолжает работу как будто исключение выброшено кодом после блока `finally`.

1. При появлении исключения CLR обнуляет его начальную точку. То есть CLR запоминает только место появления самого последнего исключения. Это объясняет отличие `throw ex;` от `throw;` В первом случае это полноценный выброс исключения, пусть и того же самого, но начальная точка уже новая. Во втором случае начальная точка остаётся исходной.

1. StackTrace содержит информацию куда должен *вернуть* управление поток, а не откуда *произошло обращение*.

1. `OutOfMemoryException`, `TypeInitializationException` можно перехватить в `catch`.

1. Невозможно перехватить исключение, выброшенное в методе-финализаторе.

1. Настоящий `StackOverflowException` перехватить нельзя. Можно перехватить только если его вручную выбросить самому.

1. `finally` автоматически используется: `lock` (снятие блокировки), `using` (вызов Dispose), `foreach` (вызов Dispose для IEnumerator), деструктор (вызов Finalize базового класса).

1. В момент появления исключения CLR ищет в этом месте и вверх по стеку блоки `catch` способные его обработать.

---

## Источники

1. [[CLR via C# book]]

## Ссылки

1. link
