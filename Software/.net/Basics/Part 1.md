---
date: 2023-11-02
---
# Part 1

1. **Члены типа**: поля, константы, свойства, индексаторы, события, методы, конструкторы, деструкторы, вложенные типы.

1. **Константы** - логически относятся не к экземплярам, а к типам. Могут быть только примитивных типов.

1. ```partial``` говорит компилятору о том, что исходный код класса(в т.ч. статического), структуры, интерфейса размещён в нескольких файлах. Partial методы: не могут иметь модификатора доступа(компилятор сам делает их private), должны возвращать void, не могут иметь out параметров. Если метод объявлен в одном месте, но в итоге так и не реализован, то компилятор просто вырезает его.

1. Безопасным считается **приведение типов**: к базовому типу и без потери точности(для чисел). Безопасное можно делать неявно. Операторы is, as никогда не выбрасывают исключения.

1. На **стек** каждого потока выделяется 1 Мб памяти. Она используется для передачи параметров в методы и для хранения локальных переменных методов.

1. В управляемой куче. **В объекте хранится**: ссылка на объект-тип, индекс блока синхронизации, экземплярные поля. В объекта-типе: ссылка на объект-тип(```System.Type```), индекс блока синхронизации, статические поля, таблица с методами типа, в которой для каждого метода указано где лежит его IL-код или уже машинный код(если однажды вызвали и он скомпилирован).

1. **Упаковка** - процесс преобразования значимого типа в тип ```object``` или в любой тип интерфейса, реализуемый этим значимым типом. Упаковка является неявной, распаковкам - всегда явная.

1. Примитивный тип ```dynamic``` подходит для работы с COM и интеграции с динамическими языками(python, ruby).

1. **Не может быть статических структур!** Для структур всегда должна быть возможность создать ее экземпляр.

1. ```readonly``` поле ссылочного типа означает, что этому полю нельзя переприсвоить ссылку, а вот сам объект, на который оно ссылается, можно менять. При обращении к readonly полям значимого типа будет генерироваться временная переменная(статья о вреде изменяемых значимых типов).

1. **Конструкторы типов**: могут быть как у ссылочных, так и у значимых типов; может быть только один у типа; не может содержать параметров; не может иметь модификаторы доступа. Конструктор типа для значимых не стоит использовать, потому что CLR не всегда его вызывает.

1. **Перегрузка операторов**

```csharp
public static Point operator +(Point p1, Point p2)
public static implicit operator Rational(int num)
```

1. **Метод расширения** - это статический метод, объявленный в статическом необобщенном классе, первый параметр которого помечен к. словом this. Это синтаксический сахар, имитация вызова экземплярного метода. Но для компилятора вызов м. расширения - это просто вызов статического метода. М. расширения могут быть определены для: типы(ссылочные и значимые), интерфейсы, делегаты, перечисления.

1. **Параметры со значением по умолчанию** не могут быть ref, out.

1. Можно создавать перегрузки методов, отличающихся только наличием ```ref/out```. Но нельзя, если методы одинаковые и в одном ``ref``, а в другом - ``out``. Потому что компилятор генерирует идентичный код для ref и out параметров. Переменные, которые мы передаём в ```ref/out``` параметры должны быть строго указанного в сигнатуре типа(дочерний класс уже не подойдёт).

1. ```params``` может быть помечен только последний параметр метода.

```csharp
void Add(params int[] values)
```

```Add()``` = передать пустой массив
```Add(null)``` - более эффективно, потому что даже не выделяет память под массив

1. К свойствам нужно относится с осторожностью: оно выглядит как поле, но по сути является методом. Свойство нельзя передавать как ref/out параметр в метод.

1. **Индексатор** (свойство с параметрами) может быть только экземплярным(статическим не может быть, потому что используется this), может иметь один или несколько параметров, может быть перегруженным(по умолчанию то в качестве имя берётся имя экземпляра). Можно задать отдельное имя для индексатора с помощью атрибута IndexerName.

1. **Анонимные типы** - это синтаксический сахар. Компилятор генерирует класс, соответствующие readonly свойства и конструктор, переопределяет некоторые методы класса object. Так что под капотом - это работа с полноценным классом, просто к нему нет прямого доступа у программиста.

1. Событие компилятор разворачивает во всегда закрытое поле-делегат и два метода-доступа: добавление и удаление подписчиков. Вот эти методы уже могут быть статическими, виртуальными, абстрактными, короче такими как описано само событие в исходном коде. В методе Dispose следует добавлять отписку от событий, иначе объект не будет собран GK.

1. Обобщение(generic) - способ многократного использования алгоритмов. Открытый тип - это обобщенный тип, для которого не определены все параметры типа, закрытый - для которого все определены. Нельзя создать экземпляр открытого типа. Для каждого варианта закрытого типа CLR создаёт новый объект-тип, содержащий статические поля. Аналогично и статический конструктор вызывается однажды для конкретного варианта закрытого типа. Наследование: ```List<T>``` - наследник ```object```, ```List<string>``` будет также наследником ```object``` (а не ```List<T>```). CLR оптимизирует: код обобщенного метода компилируется только однажды для всех ссылочных типов, потому что по сути ссылка есть ссылка(32 или 64х разрядный указатель на объект в памяти). Для значимых типов так нельзя, там для каждого своя версия скомпилированного метода.

1. При выведении типов для обобщенных методов компилятор смотрит на тип переменной, а не на фактический тип объекта, на который ссылается переменная.

1. У свойств, событий, операторных методов, конструкторов, деструкторов не может быть параметров типа. Они могут использовать параметр типа класса, если они расположены в обобщенном классе. А вот методы могут быть обобщенными, находясь в необобщенном классе.

1. При переопределении виртуального обобщённого метода можно изменять только имена параметров типов, но не их количество и ограничения.

1. Ограничения при обобщении. **Основное**: конкретный ссылочный тип(можно будет передать его или производный; нельзя здесь передавать Object, ValueType, Enum, Delegate, MulticastDelegate), class, struct. Основное ограничение может быть не более одного. **Дополнительные**: интерфейс, связь между параметрами типа(один наследует от другого). Дополнительных может быть ноль и более. **Ограничение конструктора** гарантирует, что будет указан тип, экземпляр которого можно создать(не абстрактный) и он имеет конструктор без параметров.

```csharp
void SomeMethod<T>(T o) {
   int a = (int) o; // Ошибка
   string s = (string) o; //Ошибка
   int b = (int)(object) o; //Ok
   string p = (string)(object) o;} // Ok
```

Вместо присваивания ```null``` лучше использовать ```default(T)```. Если явно не прописано ограничение ссылочного типа, то не удастся присвоить ```null```.

Проверка ```==``` допустима только для ссылочных типов. Несмотря на то, что примитивные числовые типы ее поддерживают, не факт что не будет передана кастомная структура. Аналогично математические операторы недопустимы даже несмотря на наличие ограничения struct.

1. Контр- и ковариантность позволяют формировать иерархию производных типов(имеется ввиду ```string``` - исходный тип, ```Action<string>```, ```IEnumerable<string>``` - производные) на основе иерархии исходных типов.
**Контрвариантность**(```in```) - параметр тип, находящийся во входной позиции, может быть преобразован к типу-наследнику. Контравариантностью называется обращение иерархии исходных типов на противоположную в производных типах. Так, если класс String наследуется от класса Object, а делегат ```Action<T>``` определён как метод, принимающий объект типа ```T```, то ```Action<object>``` наследуется от делегата ```Action<string>```, а не наоборот.
**Ковариантность**(```out```) - параметр тип, находящийся в выходной позиции, может быть преобразован к типу-родителю. Ковариантностью называется сохранение иерархии наследования исходных типов в производных типах в том же порядке. Так, если класс Cat наследуется от класса Animal, то естественно полагать, что перечисление IEnumerable<Cat> будет потомком перечисления ```IEnumerable<Animal>```.

```csharp
delegate TResult Func<in T, out TResult>(T arg);
Func<Object, ArgumentException> f1;
Func<String, Exception> f2 = f1; //Ok
```

Тут благодаря вариантности считаем, что тип ```Func<Object, ArgumentException>``` производный от ```Func<String, Exception>```, потому что контрвариантный входной параметр в производном типе инвертировал иерархию наследования ```string:object```, а ковариантный выходной параметр сохранил направление наследования ```ArgumentException:Exception```.
27. Если наследование класса-это наследование сигнатур и реализаций, то в случае интерфейса - это наследование сигнатур. Интерфейсы могут содержать только экземплярные методы, свойства, события. При явной реализации метода интерфейса не нужно указывать модификатор доступа.
28. LINQ - язык интегрированных запросов. Позволяет создавать запросы к разным источникам данным, используя один и тот же синтаксис. Источником данных может быть коллекция данных, реализующая ```IEnumerable<T>``` или производный от него ```IQueryable<T>```.

---

## Источники

1. [[CLR via C# book]]

## Ссылки

1. link
