---
date: 2023-11-03
---
# Символы и строки

1. **Символы** представлены 16-разрядным кодом стандарта Юникод. Самый оптимальный способ конвертации- приведение типов: char->int. Для хранения строк [используется](https://learn.microsoft.com/en-us/dotnet/standard/base-types/character-encoding-introduction#utf-16-code-units) кодировка UTF-16.

1. **Неизменяемость строк** даёт возможность: отсутствие необходимости синхронизации потоков, оптимизации(интернирование и др.). Класс string тесно интегрирован с CLR для получения максимальной производительности, например CLR знает о порядке расположения полей в нем. Чтобы не нарушить эту связь string является запечатанным.

1. Все строковые литералы, которые есть в исходном коде, записываются в метаданные исполняемого модуля. Для уменьшения размера хранимых данных путем экономии места для одинаковых литералов, в метаданных создается пул строк. При загрузке CLR строки из метаданных записываются в спец хэш-таблицу(**пул интернирования**): ключ-литерал, значение-ссылка на область в куче.

1. **StringBuilder** содержит массив символов и манипулирует им. При вызове ToString() создаёт экземпляр строки. При этом дальнейшие манипуляции не затронут сформированную строку, а также будут проводится над массивом символов. Билдер характеризуется максимальной и текущей длиной массива символов. При переполнении имеющегося массива автоматически создаётся новый большего размера.

1. Интерфейс **IFormattable** содержит метод ToString, возвращающий строковое представление об'екта. Метод принимает: формат(string) и описание культурных настроек, которые нужно использовать(IFormatProvider). Метод Object.ToString() эквивалентен IFormattable.ToString(null, null). IFormatProvider реализуют CultureInfo, NumberFormatInfo, DateTimeFormatInfo.

1. Стандартно каждый символ представлен 16-разрядным кодом Юникода. Но 2 байта избыточно для многих символов(особенно английских). Поэтому при записи в файл или передачи по сети строки могут кодироваться с использованием разных кодировок. Utf-16 работает быстро, но не даёт сжатия, т.к. представляет те же 2 байта. Utf-8 представляет символы в виде от 1 до 4 байтов, поэтому может давать выигрыш.

1. Для получения объекта для кодирования/декодирования нужно использовать статические методы класса **Encoding**. Там есть для конкретных кодировок или общий метод, возвращающий кодовую страницу по Ее имени или номеру. Эти статические методы оптимизированы и возвращают один и тот же объект при запросе одной и той же кодировки.

1. **BOM**(byte order mark) или preamble - первые несколько байтов потока, которые помогают правильно определить его кодировку.

1. Когда чтение из потока идет порциями, то символы могут оказаться разбитыми в разных порциях. Чтобы нормально это прочитать нужно использовать System.Text.Decoder. Плюс есть аналогичный Encoder.

1. Для хранения секретных данных string может не подходить, потому что данные хранятся в памяти и теоретически могут быть прочитаны неуправляемым кодом. Для таких случаев есть класс **SecureString**. Он хранит строки в зашифрованном виде в неуправляемой память, к которой даже у GC нет доступа.

1. Несмотря на то, что строки - это ссылочный тип, метод ```Equals``` и оператор ```==``` выполняет сравнение их значений. Это сравнение *case-sensitive* и игнорирует культуру. При этом методы ```Compare```  и ```CompareTo``` ориентируются при сравнении на текущую структуру. [Doc](https://learn.microsoft.com/en-us/dotnet/csharp/how-to/compare-strings).

---

## Источники

1. [[CLR via C# book]]

## Ссылки

1. link
