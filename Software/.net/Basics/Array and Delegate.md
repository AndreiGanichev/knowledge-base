---
date: 2023-11-03
---
# Array and Delegate

1. **Перечислимый тип**(ПТ)- набор пар имя-значение. ПТ не может иметь методов(можно обойти с помощью методов расширения), свойств, событий. В основе ПТ лежит примитивный числовой тип: ```(s)byte, (u)short, (u)int, (u)long```. ```int``` - по умолчанию. Здесь именно примитивные типы: ```Int32``` например не подойдёт, потому что из состава FCL.

1. Массивы бывают одномерные(векторы), двух-, трехмерные и нерегулярные(массивы массивов). Массивы элементов ссылочного типа поддерживают приведение. Для этого необходимо: одинаковая размерность массивов, между типами элементов должно быть явное или неявное преобразование. Массивы элементов значимого типа хранит сами значения, а ссылочного- только ссылки. Поэтому ```Array.Copy()``` для ссылочных типов выполняет поверхностное копирование.

1. Объявление переменной ```FileStream[] fsArray;``` приводит к созданию компилятором в домене приложений нового типа-наследника ```System.Array```.

1. С помощью статического метода ```Array.CreateInstance``` можно создать массив с ненулевой нижней границей. Но лучше не использовать такие, потому что работа с массивами с нулевой нижней границей оптимизирована. Например в цикле for проверка на невыхождения индекса за пределы выполняется только однажды - в самом начале.

1. Делегат можно рассматривать как оболочку для метода или как ссылку на метод. В делегат можно положить как статический так и экземплярный метод. В случае экземплярного метода, ему при вызове будут доступны данные этого экземпляра, потому что при создании неявно передаётся this. Простое объявление делегата компилятор преобразует в полноценный класс, наследующий от ```MulicastDelegate```, с тремя открытыми методами: ```Invoke, BeginInvoke, EndInvoke```, и закрытыми полями: ссылка на экземпляр(если экземплярный метод), указатель на метод, список вызова(если цепочка методов).

1. В случае цепочки методов "основной" делегат является контейнером. Неважно на какой экземпляр и метод он указывает, но он содержит список ссылок на "рабочие" делегаты. При добавлении/удалении делегата из цепочки всегда создаётся новый делегат-контейнер с обновлённым списком "рабочих" делегатов. При вызове цепочки методов есть доступ только к результату работы последнего метода и нет возможности обработать ошибки при работе методов. Этого можно добиться получив список делегатов цепочки методом ```GetInvocationList()``` и вызвав вручную делегаты цепочки.

1. Делегаты(не обязательно обобщенные) поддерживают контр и ковариантность, но только для ссылочных типов.

Упрощения при работе с делегатами:

1. если метод принимает делегат или мы инициализируем переменную-делегат, то можно не создавать явно экземпляр делегата, а передать/присвоить сразу метод.
1. Вместо метода в п.1 можно передать присвоить *лямбда-выражение*. В итоге компилятор создаст приватную анонимную функцию и ее уже передаст в делегат.

---

## Источники

1. [[CLR via C# book]]

## Ссылки

1. link
