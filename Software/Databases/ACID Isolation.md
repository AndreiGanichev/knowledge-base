---
date: 2023-11-22
tags:
    - mvcc
---
# Isolation

Данное свойство призвано обеспечить конкуррентное выполнение транзакций *изолировано*: таким образом, чтобы избежать различных *аномалий*. Клепман описывает это как "they cannot step on each other’s toes". Речь именно о конкурренци и как следствие возможной *race conditions*. Потому что *параллельные* транзакции, не конкурирующие за те же самые данные можно выполнять как угодно - они независимые.

У изоляции существуют разные уровни, каждый из которыхпредоставляет определенные гарантии, которые в свою очередь уберегают от тех или иных аномалий.

## Serializable

От слова *serial*(последовательный). Гарантирует, что результат выполнения конкурретных транзакций будет таким, который получился бы, если эти транзакции выполнить *в каком-то* порядке строго последовательно.

## Weak isolation levels

Все, что не serializable Клепман называет слабыми уровнями. Разные уровни предоставляют разные гарантии, устраняя определенный набор аномалий.

### Dirty writes

Транзакция Т2 изменяет данные, которые были изменены, но еще не закоммичены транзакцией Т1.

![Dirty writes](Images/Dirty%20writes.png) [[Designing Data-Intensive Applications book]]. Chapter 7. Fig. 7-5.

Проблема в том, что по итогам выполнения обоих транзакций БД остается в несогласованном состоянии: каждая из транзакций оказывается выполненной частично.

### Решение

При выполнении изменений брать *write lock* (`exclusive lock` в MySql) на записи(rows), которые участвуют в операции. Чтение этих записей не блокируется, а вот другие операции записи будут ждать завершения текущей, прежде чем получить доступ к блокировке.

---

### Dirty reads

Транзакция Т2 вычитывает данные, которые были изменены, но еще не закоммичены транзакцией Т1.

Во-первых, вычитанные данные могут быть в итоге не закомиченны. Во-вторых, результат чтения будет несогласован - это смесь наполовину выполненных операций транзакции.

### Решение

Помимо версии записи, которая сделана в рамках текущей незакомиченной транзакции, хранить последнюю закомиченную версию записи. При чтении из других транзакций возвращать именно последнюю закомиченную версию. Можно назвать упрощенной версией MVCC.

---

### Read skew / Nonrepeatable read / Phantom read

В ходе выполнения транзакции Т1 несколько раз выполняется чтение одних и тех же данных. После первого чтения данные были изменены и закомиченны в транзакции Т2. Тогда второе чтение тех же данных в рамках Т1 вернет уже другой результат.

Вероятность этой аномалии повышается для долгих запросов на чтение: выполнение бэкапа БД или аналитические запросы. В итоге таких запросов получим смесь даннных, которые были в БД в разное время выполнения этого долгого запроса.

### Решение 1

Брать блокировку на чтение аналогичную записи, т.е. вычитанные данные будут заблокированы для записи до конца транзакции. Это можно сделать с помощью *exclusive* и *shared* блокировок(см. пример [[InnoDB locks]]). Тут очевидно будет снижение производительности.

### Решение 2

Хранить старые версии при обновлении данных - *Multi-version concurrency control*. Это обобщенный подход решения, которое используется для борьбы с *dirty reads*. Каждая версия данных помечена идентификатором транзакции, в которой выполнено изменение. Идентификаторы транзакций монотонно возрастают. При выполнении чтения в рамках транзакции запоминается тот идентификатор транзакции K, данные с которым были вычитаны в первый раз. Дальнейшее чтение будет игнорировать версии данных, которые имеют идентификаторы транзакций больше K. В итоге учитывая идентификаторы транзакций можно получить слепок(*snapshot*) данных на момент выполнения любой транзакции.

MVCC позволяет добиться того, то *запись не блокирует чтение, а чтение не блокирует запись*.

**Удаление неактуальных версий:** нецелесообразно хранить все версии данных с начала работы СУБД. Версии данных, у которых идентификаторы транзакций уже не "отслеживаются" ни одной из выполняемых транзакций в данный момент, можно удалять.

Отдельной задаче в случае MVCC является поддержание MVCC для индекса. Одним из решений является хранение всех версий записи в индексе. Но также существуют и оптимизации:

1. не вносить изменения в структуру индекса, если несколько версий записи умещаются на одну страницу индекса
1. при использовании подхода copy-on-write страницы/узлы дерева являются неизменяемыми и при необходимости изменений страница копируется вместе со всеми родителями вплоть до корня. Т.о. каждой транзакции фактически соответствует новый корень, который является точкой входа для снапшота данных на момент завершения транзакции.

---

### Lost updates

Аномалия может возникнуть при выполнении *read-modify-write* последовательности. Конкурирующие транзакции Т1 и Т2 могут одновременно вычитать одни и те же данные, модифицировать их и записать. В итоге в БД останутся данные той транзакции, которая окажется последней, а запись первой завершенной транзакции будет потеряна.

Примером может быть ингремент счетчика.

![Lost updates](Images/Lost%20updates.png)

### Решение 1

НАилучшим решением будет использование атомарных операций, которые предоставляет СУБД.

```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

### Решение 2

Явно взять блокировку(*exclusive*) на обновляемую запись.

### Решение 3

Использовать *compare-and-set(CAS)* подход: выполнять изменение только в случае если в БД хранится нужная версия данных. На этом же подходе основана реализация [optimistic concurrency](https://www.kamilgrzybek.com/blog/posts/handling-concurrency-aggregate-pattern-ef-core) на уровне приложения.

### Решение 4

Некоторые СУБД умеют автоматически отслеживать эту аномалию и абортить транзакции при обнаружении: lost updates detecting.

### Write skew / Phantoms

В случае *dirty write* и *lost updates* существует явная конкуренция за один и тот же ресурс(row). *Write skew* напоминает *lost updates*, потому что в обеих аномалиях есть read-modify-write цикл. Но write skew стоит особняком, потому что она возникает даже когда обновление данных затрагивает разные rows.

Клепман приводит такой пример: приложение для врачей может дать отгул врачу только, если в этот же момент на смене есть другой врач. Иначе - нельзя отпроситься. Логика приложения реализована так, что перед запросом на отгул проверяется наличие врачей на смене помимо отпрашиваемого. Но может произойти ситуаций, когда эта логика сработает дл Alice и Bob одновременно и запросы для обоих врачей вернут ответ, что напарник на смене. В итоге оба врача смогут взять отгул и на смене никого не останется

![Write skew](./Images/Write%20skew.png)

Еще примеры:

1. создание пользователя с уникальным логином: проверили, что такого логина нет в БД и добавляем. По своей природе это write skew, если одновременная проверка двумя пользователями показала, что логин свободен и создаются две уетных записи с одинаковыми паролями.
1. система бронирования переговорок: проверяем, что данная переговорка еще не занята на нужный период и бронируем.

```sql
SELECT COUNT(*) FROM bookings WHERE room_id = 123 AND end_time > '2015-01-01 12:00' AND start_time < '2015-01-01 13:00';
```

1. в многопользовательской игре нужно решить доступна ли клетка поля(свободна) для перемещения в нее для игрока или нет.
1. списание денег со счета: проверяем есть ли на счете нужная сумма перед списанием

Во всех примерах имеем один и тот же паттерн:

1. делаем SELECT данных, удовлетворяющих определенному *условию*
1. на основе полученных данных бизнес логика принимает решение
1. записываем изменения в БД

Важным здесь является то, что **результат записи в п.3 изменяет результат выборки данных в п.1**: больше нет напарника на смене, переговорка становится занятой, имя пользователя становится занятым.

### Решение 1

В некоторых случаях можно добавить ограничение на уровне БД, которое защищало бы инварианты бизнес логики на уровне схемы данных. В примере с уникальным именем пользователя достаточно добавить уникальный индекс.

### Решение 2

В некоторых случаях можно обойтись явными блокировками. Например при выборке врачей на смене можно заблокировать прочитанные данные, что заставит конкурентную транзакцию подождать и сделать чтение уже после завершения текущей транзакции.

### Решение 3

Блокировка не может решить *write skew*, если ее не на чем взять, как в примере с бронированием переговорных. Хотя существуют [[InnoDB locks|next-key locks]], которые могут блокировать все пространство между значениями в индексе.

Также применяют подход *materializing conflicts*: проектируют схему данных таким образом, чтобы существовали rows, на которых можно взять блокировку. В примере с бронированием Клепман предлагает вместо бронирования произвольного промежутка создать заранее фиксированные слоты времени, которые можно было бы блокировать при чтении (FOR UPDATE).

---

## Источники

1. [[Designing Data-Intensive Applications book ]] Chapter 7. Transactions

## Ссылки

1. #[[ACID]]
1. [[Isolation levels]]
