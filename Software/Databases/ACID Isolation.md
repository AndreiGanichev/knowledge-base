---
date: 2023-11-22
tags:
    - mvcc
---
# Isolation

Данное свойство призвано обеспечить конкуррентное выполнение транзакций *изолировано*: таким образом, чтобы избежать различных *аномалий*. Клепман описывает это как "they cannot step on each other’s toes". Речь именно о конкурренци и как следствие возможная *race conditions*. Потому что *параллельные* транзакции, не конкурирующие за те же самые данные можно выполнять как угодно - они независимые.
У изоляции существуют разные уровни, каждый из которыхпредоставляет определенные гарантии, которые в свою очередь уберегают от тех или иных аномалий.

## Serializable

От слова *serial*(последовательный). Гарантирует, что результат выполнения конкурретных транзакций будет таким, который полуился бы, если эти транзакции выполнить *в каком-то* порядке строго последовательно.

## Weak isolation levels

Все, что не serializable Клепман называет слабыми уровнями.

### Dirty writes

Транзакция Т2 изменяет данные, которые были изменены, но еще не закоммичены транзакцией Т1.

![Dirty writes](Images/Dirty%20writes.png) [[Designing Data-Intensive Applications book ]]. Chapter 7. Fig. 7-5.

### Решение

При выполнении изменений брать *write lock* (`exclusive lock` в MySql) на записи(rows), которые участвуют в операции. Чтение этих записей не блокируется, а вот другие операции записи будут ждать завершения текущей, прежде чем получить доступ к блокировке.

---

### Dirty reads

Транзакция Т2 вычитывает данные, которые были изменены, но еще не закоммичены транзакцией Т1.

Во-первых, вычитанные данные могут быть в итоге не закомиченны. Во-вторых, результат чтения будет несогласован - это смесь наполовину выполненных транзакций.

### Решение

Помимо версии записи, которая сделана в рамках текущей незакомиченной транзакции, хранить последнюю закомиченную версию записи. При чтении из других транзакций возвращать именно последнюю закомиченную версию.

---

### Read skew / Nonrepeatable read / Phantom read

В ходе выполнения транзакции Т1 несколько раз выполняется чтение одних и тех же данных. После первого чтения данные были изменены и акомиченны в транзакции Т3. Тогда второе чтение тех же данных в рамках Т1 вернет уже другой результат.

Вероятность этой аномалии повышается для долгих запросов на чтение: выполнение бэкапа БД или аналитические запросы. В итоге таких запросов получим смесь даннных, которые были в БД в разное время выполнения этого долгого запроса.

### Решение 1

Брать блокировку на чтение аналогичную записи, т.е. вычитанные данные будут заблокированы для записи до конца транзакции. Это можно сделать с помощью *exclusive* и *shared* блокировок(см. пример [[InnoDB locks]]). Тут очевидно будет снижение производительности.

### Решение 2

1. Хранить старые версии при обновлении данных - *Multi-version concurrency control*. Это обобщенный подход решения, которое используется для борьбы с *dirty reads*. Каждая версия данных помечена идентификатором транзакции, в которой выполнено изменение. Идентификаторы транзакций монотонно возрастают. При выполнении чтения в рамках транзакции запоминается тот идентификатор транзакции K, данные с которым были вычитаны в первый раз. Дальнейшее чтение будет игнорировать версии тех же данных, которые имеют идентификаторы транзакций больше K. В итоге учитывая идентификаторы транзакций можно получить слепок(*snapshot*) данных на момент выполнения любой транзакции.

MVCC позволяет добиться того, то *запись не блокирует чтение, а чтение не блокирует запись*.

**Удаление неактуальных версий:** нецелесообразно хранить все версии данных с начала работы СУБД. Версии данных, у которых идентификаторы транзакций уже не "отслеживаются" ни одной из выполняемых транзакций в данный момент, можно удалять.

---

### Lost updates

Аномалия может возникнуть при выполнении *read-modify-write* последовательности. Конкурирующие транзакции Т1 и Т2 могут одновременно вычитать одни и те же данные, модифицировать их и записать. В итоге в БД останутся данные той транзакции, которая окажется последней, а запись первой завершенной транзакции будет потеряна.

Примером может быть ингремент счетчика.

![Lost updates](Images/Lost%20updates.png)

### Решение 1

Использование атомарных операций, которые предоставляет СУБД.

```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

### Решение 2

Явно взять блокировку(*exclusive*) на обновляемую запись.

### Решение 3

Использовать *compare-and-set(CAS)* подход: выполнять изменение только в случае если в БД хранится нужная версия данных. На этом же подходе основана еализация [optimistic concurrency](https://www.kamilgrzybek.com/blog/posts/handling-concurrency-aggregate-pattern-ef-core) на уровне приложения.

### Решение 4

Некоторые СУБД умеют автоматически отслеживать эту аномалию и абортить транзакции при обнаружении.


### Write skew


---

## Источники

1. [[Designing Data-Intensive Applications book ]] Chapter 7. Transactions

## Ссылки

1. #[[ACID]]
