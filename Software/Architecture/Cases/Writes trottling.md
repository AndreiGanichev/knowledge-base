---
date: 2023-04-05
tags:
    - tag
---

## Дано

**Запись:** сервис потребляет события от брокера сообщений и сохраняет их в БД. Нагрузка имеет пиковый характер. Допустима значительная задержка обработки событий.
**Чтение:** сервис имеет web apiи отвечает на клиентские запросы
Брокер

## Задача

Сделать так, чтобы сервис отвечал на запросы на чтение даже в случае пиковой нагрузки на запись.


## Решения

Решение зависит от используемого брокера сообщений. *RabbitMq* имеет ораничения на кол-во сообщений, которые одновременно могут назодится в очередях. Значит накапливание сообщений может начать аффектить другие сценарии использовани *RabbitMq*(т.к. он является единой точкой интеграции микросервисов) и в итоге привести к падению брокера. *Kafka* лишена этого недостатка и сообщения просто будут записываться и ждать когда обработчики вычитают их.

### Решение 1 (Kafka)

В случае, если можно обойтись всего одним экзмпляром сервиса, то можно использовать [ReaderWriterLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlock?view=net-7.0), чтобы реализовать функции [[Trottling pattern]]. В случае пиков сообщения будут копиться в брокере.

### Решение 2 (Kafka)

В случае, если одного экземпляра мало и нужно масштабирование, то можно использовать [[Distributed lock]] или [[Rate limit pattern]] на запись. В этом случае для lock или хранения лимитов можно использовать отдельную коллекцию/контейнер(в случае документоориентированной БД), на которую настроить отдельный *throughput*. Этим гарантируется то, что работа с этими данными будет доступнаа даже если пиковые записи заблокируют коллекцию с основными данными.

### Решение 3 (Kafka)

Разделяем деплойменты для web api и обработчиков сообщений. Настраиваем кол-во экземпляров для обработчиков и скорость обработки сообщений так, чтобы генерируемая запись гарантировано не влияла на чтение

### Решение 4 (RabbitMq)

Делаем две коллекции: на запись и на чтение с независимым *throughput*. При обработке сообщений из брокера пишем смело так быстро, как позволяет *throughput* в соответствующую коллекцию. Этим стразуемся от накопления сообщений в очереди. Переливание событий в коллекцию на чтение делаем спостоянной скоростью и так, чтобы оно не влияло на обработку входящих запросов на чтение.

---

### Источники:
1. link

### Ссылки:
1. [[Kafka basics]]