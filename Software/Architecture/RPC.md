---
date: 2023-04-10
tags:
    - integration pattern
---
# RPC

Это модель, предполагающая, что вызовы удаленных сервисов по сети выглядят как вызовы обычных методов программы в том же процессе. Таким образом обеспечивается [location transparency](https://en.wikipedia.org/wiki/Location_transparency)

## Недостатки идеи

1. удаленный сервис в отличие от кода, выполняющегося в том же процессе, полностью вне нашего контроля. Cервис может медленно обрабатывать запрос или отказать(эти состояния не всегда просто отличить, см. [[Failure detection]]). Необходимо использовать [[Timeout pattern]].
1. запрос может дойти и сервис выполнить свою работу, но потеряться может ответ. Тогда как локальный вызов гарантированно либо выполнится успешно, либо завершиться исключением.
1. время обработки запросов удаленным сервисом может сильно отличаться от запроса к запросу в отличие от стабильных и предсказуемых вызовов в одном процессе.
1. в случае *timeout* можно попробовать повторить запрос([[Retry pattern]]), но с учетом вышеописанных проблем нельзя быть уверенным, что изначальный запрос не дошел успешно и не выполнился на удаленном сервисе. Чтобы не бояться повтора выполнения уже выполненной операции, то API удаленного сервиса должно обеспечивать свойство [[Idempotency]]
1. при вызове функции локально ей можно передать указатель в качестве параметра. При удаленном вызове все данные нужно передать непосредственно в запросе.
1. возможно несоответствеи типов данных языков программирования клиента и удаленного сервиса

## Чистая архитектура

Роберт Мартин в книге Чистая архитектура и статьях своего блога называет механизм взаимодействия деталью реализации и указывает, что следует **на уровне архитектуры** абстрагироваться от него.

> If the code of the components can be written so that the communications mechanisms, and process separation mechanisms are irrelevant, then those **mechanisms are details**. And details are never part of an architecture.

Конечно на уровне архитектуры мы должны разделять бизнес логику от инфраструктуры и абстрагироваться от *конкретного* способа реализации. Но полностью обеспечить *location transparency* очень трудно. Об этом [пишет](https://twitter.com/stilkov/status/517982267688632320?s=20) Stefan Tilkov (нашел только твит, но была еще его статья в блоге).

## Leaky abstraction

Получается что не удается полноценно абстрагироваться от способа вызова функции: локально или удаленно. RPC - это [[Leaky abstraction]].

Сергей Баранов на своем курсе о микросервисах приводил такую аналогию, которая позволяет лучше осознать разницу локального и удаленного вызова: *удаленный вызов это как будто вы играете в компьютерную игру и вдруг в процессе игры все останавливается и вас просят вставить другой диск. Игра продолжается только после того, как вы вынете один диск и вставите другой*.

С точки зрения человека удаленные вызовы мгновенны и надежны, каждый раз работая в браузере мы видим их результаты. Но их скорость на уровне компьютера отличается **на порядок** от скорости локальных вызовов, что делает невозможным абстрагироваться от реализации вызова.

## RPC vs [[REST]]

В отличие от концепции RPC REST пытается скрывать, что является подходом для сетевого взаимодействия, явно и широко используетиспользует фичи HTTP.

## [[Compatibility]]

При условии, что сначала всегда обновляется сервер, а потом уже клиент, для RPC требуется:

1. прямая совместимость для *реквеста* - новая версия сервера может читать реквест от старой версии клиента
1. обратная совместимость для *респонза* - старая версия клиента может прочитать респонз от новой версии сервера

---

## Источники

1. [[Designing Data-Intensive Applications book]]. Chapter 4. The problem with RPCs.

## Ссылки

1. [[Async vs sync]]
1. [Clean Micro-service Architecture](https://blog.cleancoder.com/uncle-bob/2014/10/01/CleanMicroserviceArchitecture.html)
1. [Microservices and Jars](https://blog.cleancoder.com/uncle-bob/2014/09/19/MicroServicesAndJars.html)
