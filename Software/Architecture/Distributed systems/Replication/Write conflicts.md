---
date: 2023-08-13
---
# Write conflicts

Конфликты возникают, когда есть несколько копий данных, которые обрабатывают запросы на запись:

1. [[Multi leader replication]]
1. [[Leaderless replication]]

![Write conflict example](../../Images/Write%20conflicts.png) [[Designing Data-Intensive Applications book ]]. Chapter 5. Fig. 5-7.

## Время обнаружения конфликта

1. синхронно - в момент выполнения записи клиентом. Этим занимается лидер в [[Single leader replication]] и может вернуть ошибку клиенту.
1. асинхронно - в момент репликации. Клиента в этот момент уже нет "на связи", он уже получил "успех" по своей записи.

## Стратегии работы с конфликтами

### Избежание конфликтов

Например, использование [[Single leader replication]] в чистом виде или в случае [[Multi leader replication]] все запросы на запись конкретного клиента [[Load balancing|направлять]] **всегда** на одного и того же лидера.

### Converging toward consistent state

Цель данной стратегии - в итоге (*eventually*) получить одинаковые данные на всех репликах.

1. *Last write wins (LWW)*. Каждая операция записи сопровождается timestamp, ID, хэшом или чем-то еще, позволяющем сравнивать эти значения. При обработке обновлений запись игнорируется, если ее timestamp ниже, чем уже сохранена на реплике. Это простой подход, но может приводить к потере данных.
1. Договориться, что у каждой реплики есть ID и записи, которые сделаны изначально на реплику с бОльшим ID должны идти до записей с меньшим ID.
1. записывать всею имеющуюся информацию о конфликте и предлагать коду приложения решать конфликт при чтении.

---

## Источники

1. link

## Ссылки

1. link
