---
date: 2022-05-28
tags:
    - standarts
---

## Что такое и почему появился

[OpenTelemetry](https://opentelemetry.io/docs) является независимым **стандартом** для генерации, сбора и экспорта всех видов сигналов. OpenTelemetry появился в тот, момент, когда в индустрии уже существовало несколько разрозненных механизма сбора сигналов, например [OpenTracing](https://opentracing.io/) описывал только трассировку, для сбора метрик использовался инструментарий [Prometheus](https://prometheus.io/).

Эта ситуация приводила к тому, что не получалось построить единую картину в распределенной системе. Единство стандартов особенно актуально для трассировки, потому что *trace* должен проходить насквозь через все участвующие подсистемы, в том числе СУБД и интеграции с другими системами. Разные стандарты использовали разные форматы контекста трассировки и разные способы его передачи по сети. К примеру просто передавали traceId, parentSpanId в разных по имени http-заголовках. В итоге трассирока прерывалась или не было стройной иерархии спанов.

OpenTelemetry использует [W3C формат контекста трассировки](https://www.w3.org/TR/2021/REC-trace-context-1-20211123/).

## Миграция с других стандартов

Если используемый сторонний инструмент для трассировки использует OpenTracing, а мы хотим глобально использовать OpenTelemetry, то для dotnet есть [адаптер](https://opentelemetry.io/docs/instrumentation/net/shim/) ```OpenTracingShim```. Он реализует интерфейс трассировщика OpenTelemetry и внтури уже использует инструментарий OpenTelemtry для сбора трейсов.


## Sampling

Сбор и хранение трейсов от всех запросов - задача ресурсоемкая и не всегда нужная. Чтобы сэкономить, используется *sampling*. Суть его в том, что для сбора и хранения выбирается только часть запросов и получаем компромисс между полнотой сбора метрик и затрачиваемыми на это ресурсами. Алгоритмы сэмплирования делятся на два основных типа, исходя из того когда принимается решение о том, трассировать запрос или нет:

1. *head-based* - решение принимается на старте запроса и далее передается вместе с контекстом трассировки, чтобы дочерние спаны знали об этом решении
1. *tail-based* - решение принимается по итогам выполнения запроса. Это выгодно, когда например хотим обязательно трасировать, собирать метрики и логи ошибочных запросов.

---

### Источники:
1. link

### Ссылки:
1. [OpenTracingShim example](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/examples/Console/TestOpenTracingShim.cs)