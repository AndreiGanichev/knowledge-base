---
date: 2024-02-12
---
# Ordering

> there are deep connections between ordering, linearizability, and consensus. [1]

Связь выражается в том, что, реализовав один алгоритм, можно получить/реализовать и остальные.

> linearizable compare-and-set (or increment-and-get) register and total order broadcast are both equivalent to consensus. That is, if you can solve one of these problems, you can transform it into a solution for the others.

## TOB на основе линеаризуемого хранилища

Пусть в линеаризуемом хранилище хранится счетчик, поддерживающий операцию *increment-and-get*. Каждая нода перед тем как отправить сообщение обращается к этому счетчику, получает очередной индекс и прикладывает его к сообщению. Таким образом сообщения будут строго упорядочены и **без пробелов** в индексе.

Клепман пишет, что пробелы могут быть при использовании [[Lampord clock]]. Я так понимаю речь про то, что если до получателя дошли сообщения с метками ```(индекс операции, номер ноды)``````: (3,1) и (4,2), то ничего нельзя сказать придет ли какое-то сообщение между ними или нет. Потому что например может прийти сообщение (3,2) или (4,1), которое должно быть упорядочено между данными.

А вот в случае TOB если receive сообщение с индексом 2, а теперь пришло с индексом 4, то можно быть уверенным, что 4 надо отложить и подождать пока придет 3.

## Линеаризуемое хранилище на основе TOB

> Total order broadcast is asynchronous: messages are guaranteed to be delivered reliably in a fixed order, but there is no guarantee about when a message will be delivered (so one recipient may lag behind the others). By contrast, linearizability is a recency guarantee: a read is guaranteed to see the latest value written.

Допустим с помощью линеаризуемого хранилища мы хотим добиться соблюдения ограничения уникальности логина пользователя. Тогда при получении нодой запроса на создание пользователя выполняется *broadcast* этой операции. И дальше нода ожидает *deliver* этой отправленной операции.

1. Если ноде доставлена "обратно" своя же операцию, то гарантировано запрошенное имя пользователя не занято конкуррирующей операцией. В этом случае нода создает пользователя и возвращает успех.
1. Если ноде доставлена "обратно" своя же операцию, нода получает операцию от другой ноды, которая пытается создать пользователя с таким же именем, то становится понятно, что в данный момент происходит конкурирующая операция и т.к. она была доставлена(deliver) первой, то значит текущий ноде надо ответить на запрос отказом.

Т.к. на все ноды сообщения доставляются в одном и том же порядке, то все получат первым одно и то же сообщение о создании пользователя.

Описанный подход обеспечит линеаризуемую запись. В случае, если нужно линеаризуемое чтение, то для запрошенных операций чтения также надо делать broadcast и произволить чтение, и возвращать значение клиенту только когда отправленная операция чтения будет доставлена обратно. Это гарантирует, что все конкуррирующие записи будут доставлены к моменту непосредственного выполнения чтения.

## TOB на основе консенсуса

На каждое следующее сообщение можно запускать раунд консенсуса, чтобы среди предложенных нодами сообщений выбрать только одно. И это значение будет следующим в логе TOB.

## Консенсус на основе TOB

Аналогично предыдущему пункту все ноды предлагают значения, делая его broadcast. То, значение, которое будет доставлено и будет считаться решением.

---

## Источники

1. [[Designing Data-Intensive Applications book]]. Chapter 9.

## Ссылки

1. [[Linearizability]]
1. [[Consensus]]
1. [[Total order broadcast]]
