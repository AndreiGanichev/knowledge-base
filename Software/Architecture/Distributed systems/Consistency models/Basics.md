---
date: 2022-07-21
tags:
  - tag
---
# Consistency models

Повышение отказоустойчивости за счет добавления избыточности(репликация) приводит к тому, что появляется несколько копий данных. При этом операции(чтение и запись) могут выполняться одновременно разными процессами, поэтому эти копии нужно как-то синхронизировать. Сложность алгоритмов синхронизации вступает в противоречие с производительностью, с которой система как целое может обрабатывать запросы. Поэтому в рамках рассмотрения конкретной модели согласованности нужно принимать во внимание **Synchronization cost**.

Например на каждую операцию можно было бы брать распределенную блокировку или запускать алгоритм консенсуса(в том числе при выполнении операции чтения) добиваясь [[Atomic commitment]]. Но это явно приведет к снижению быстродействия системы. Поэтому с целью повышения производительности операции *write* и *replica update* разделяют.

В итоге имеем операции:

1. write
1. replica update
1. read

Похожий компромисс стоит и перед [[Transaction manager]] СУБД, работающей на одной машине: можно все транзакции выполнть строго последовательно, но тогда скорость работы СУБД будет низкой. В итоге ищутся варианты выполняить транзакции параллельно и при этом обеспечить [[ACID]]. И также как и при параллельном выполнении транзакций важным является порядок, в котором изменения становятся видимыми.

Это один из примеров, подтверждающий, что **распределенные системы имеют много общего с конкуррентными системами**. Но при этом когда речь идет о распределенных системах говорят о росте *performance*, но и о возможных проблемах с *availability*[Jepse site. Fundamental concepts. Systems](https://jepsen.io/consistency#systems)

## Проблемы синхронизации

1. **операции не происходят мгновенно**, а имеют время начала и окончания
1. из п.1 следует, что операции на разных процессах могут пересекаться, т.е. быть **concurrent**
1. **отсутствие глобальных часов** - *wall clock*. Несмотря на существование [[Network Time Protocol]] добиться синхронизации с высокой точнстью очень сложно
1. **распределенные системы по своей природе асинхронны** [[Async vs sync]] - сложно делать какие-то временнЫе допущения

## История операций

Наличие конкуррентных операций делает возможным альтернативные варианты их расстановки по временной шкале, т.е. разные _истории операций_. Это в свою очередь может приводить к разным итоговым состояниям в которых может оказаться БД.

**Consistency model** определяет какие истории операций из всех возможных комбинаций являются валидными в рамках нее, а каие - нет.

Таким образом Consistency model определяет:

1. **контракт с клиентом**: какие гарантии предоставляет
1. **семантику взаимодействия между репликами**, т.е. ограничивает варианты реализации распределенной системы

Чем *менее строгая* модель согласованности, тем *меньше гарантий* она дает и тем *больше вариантов истории операций* считаются валидными. Между моделями можно установить отношения с точки зрения "строгости": множество вариантов историй допустимые для более строгой модели является подмножеством вариантов истории, допустимых для менее строгой модели. Например варианты истории для *Linearizable* модели являются подмножеством вариантов для *Serializable* модели. Это значит, что если какая-то история является linearizable, то она автоматически будет и serializable. Между некоторыми моделями согласованности такое отношение не может быть построено.

![Consistency models relationships](../Images/Consistency%20models%20relationships.%20Jepsen.png)

---

## Источники

1. [[Database Internals book]]. Replication and Consistency.

## Ссылки

1. [[Replication]]
1. [[Monotonic reads]]#
1. [[Read your writes]]#
1. [[Write follow read]]#
