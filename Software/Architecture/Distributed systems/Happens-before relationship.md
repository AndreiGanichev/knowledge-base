---
date: 2024-02-11
---
# Happens-before relationship

> An operation A happens before another operation B if B **knows** about A, or **depends** on A, or **builds** upon A in some way.

Данное отношение также называют *causality*.

Примеры:

- create operation *happens before* update operation
- отправка запроса *happens before* получения ответа
- публикация поста в соц. сети *happens before* комментирии к этому посту
- в случае уровня изоляции [[Isolation levels|snapshot isolation]] каждая транзакция "видит" видит свой слепок БД, т.е. только те операции, которые *happens before* начала данной транзакции.

Для событий A и B возможнытри варианта отношения:

1. A *happens before* B
1. B *happens before* A
1. события [[Concurrency|concurrent]], т.е. они независимые.

В данном контексте тот факт, что события являются *сoncurrent*, не значит что они произошли в одно и то же время. На [[Clock|глобальное время]] в распределенной системе вообще нельзя полагаться. Сoncurrent означает независимые, порядок для которых нельзя определить - они  несравниваемые.

![Casuality and concurrency](./Images/Casuality%20and%20concurrency.png) [1]

Несмотря на то, что на схеме очевидно, что операция 1 закончилась раньше, чем началась операция 2, с точки зрения happens-before отношения эти операции конкуррентные. Все дело в том, что ни одна из них не знает о, не основана на другой. Клиент при отправке запросов указывает последнюю версию, о которой он знает. БД, сравнивая свою версию и версию, полученную от клиента, может сделать вывод, что операции конкуррентные и одна запись конфликтует другой. То есть *casuality* позволяет только определить конфликт, а что с этим делать зависит уже от стратегии разрешения конфликтов. Например, в случае [[Last write wins]] БД по итогам 2 операции установит значение [milk], при этом ```eggs``` потеряется. Но в данном случае используется более хитрая стратегия похожая на то как реализованы [[CRDT]]: массивы, полученные в результате конкурентных операций мержатся в один.

А вот с точки зрения [[Linearizability]] между этими операциями существет явный порядок - *real time order*.

Но т.к. БД по версии отслеживает конкуррентные операции и возвращает результаты этих операций, а клиент обрабатвыает их, то операция 4 happens before 1. Потому что клиент 2 при выполнении операции 4 был в курсе того, что в БД конкуррентно был записан массив [milk] другим клиентом. В итоге получаем такой граф зависимостей.

![Graph of causal dependencies](./Images/Graph%20of%20causal%20dependencies.png) [1]

Поэтому с точки зрения математики *happens-before* является отошением частичного порядка (*partial order*), в отличие от полного порядка (*total order*).

## Conflict resolution

Если операция А *happens before* В, то более поздняя операция В должна перезаписать более раннюю А. Это справедливо для операций 1 и 3.

А если операции *concurrent*, то появляется необходимость [[Write conflicts|conflicts resolution]]. То есть это отношение не исключает конфликтов, но позволяет их обнаружить. А разрешить конфликт возможно например с использованием [[CRDT]], так на схеме показано как автоматически мержатся два массива строк.

## Causal dependency vs LWW

На схеме также видна разница между тем, как конфликты отслеживаются с помощью happens before отношения с последующим разрешением, и как могла бы в данном случае работать стратегия [[Last write wins]]. Согласно последней по итогам операции 2 в БД должно было остаться значение [eggs], потому что эта запись пришла последней на тот момент. Тем самым было бы потеряно значение milk.

## Git

Если построить happens before связи для операций, то конкуррентные операции будут образовывать ответвления. Они позже могут сливаться обратно с возможным [[Write conflicts|conflict resolution]]. Эта картина очень напоминает историю Git, в которой как раз и отображается отношение *happens before* для коммитов.

![Git history](./Images/Git%20history.png)
Источник: [2]

Зеленые и голубые коммиты не зависят друг от друга, не основаны на знании друг от друга, они *concurrent*.

---

## Источники

1. [[Designing Data-Intensive Applications book]]. Chapter 5
1. [Atlassian documentation](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)

## Ссылки

1. [[Causal cosistency]]
1. [[Ordering]]
