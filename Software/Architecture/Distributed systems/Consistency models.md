---
date: 2022-07-21
tags:
    - tag
---

Повышение отказоустойчивости за счет добавления избыточности(репликация) приводит к тому, что появляется несколько копий данных. При этом операции(чтение и запись) могут выполняться одновременно разными процессами, поэтому эти копии нужно как-то синхронизировать. Сложность алгоритмов синхронизации вступает в противоречие с производительностью, с которой система как целое может обрабатывать запросы.

Надо отметить, что синхронизация нужна только в случае изменения данных. Если данные статичны, то проблем нет. Пример - [Content Delivery Network](https://ru.wikipedia.org/wiki/Content_Delivery_Network)

Например на каждую операцию можно было бы брать распределенную блокировку или запускать алгоритм консенсуса(в том числе при выполнении операции чтения) добиваясь [[Atomic commitment]]. Но это явно приведет к снижению быстродействия системы. Поэтому с целью повышения производительности операции *write* и *replica update* разделяют.

В итоге имеем операции:
1. write
1. replica update
1. read

Похожий компромисс стоит и перед [[Transaction manager]] СУБД, работающей на одной машине: можно все транзакции выполнть строго последовательно, но тогда скорость работы СУБД будет низкой. В итоге ищутся варианты выполняить транзакции параллельно и при этом обеспечить [[ACID]]. И также как и при параллельном выполнении транзакций важным является порядок, в котором изменения становятся видимыми.

Это один из примеров, подтверждающий, что **распределенные системы имеют много общего с конкуррентными системами**. Но при этом когда речь идет о распределенных системах говорят о росте *performance*, но и о возможных проблемах с *availability*[Jepse site. Fundamental concepts. Systems](https://jepsen.io/consistency#systems)

### Проблемы

1. **операции не происходят мгновенно**, а имеют время начала и окончания -> операции на разных процессах могут пересекаться, т.е. быть *concurrent*
1. **отсутствие глобальных часов** - *wall clock*. Несмотря на существование [[Network Time Protocol]] добиться синхронизации с высокой точнстью очень сложно
1. **распределенные системы по своей природе асинхронны** [[Async vs sync]] - сложно делать какие-то временнЫе допущения

Наличие конкуррентных операций делает возможным альтернативные варианты их расстановки по временной шкале, т.е. разные *истории операций*. Это в свою очередь может приводить к разным итоговым состояниям в которых может оказаться БД.

**Consistency model** определяет какие истории операций из всех возможных комбинаций являются валидными в рамках нее, а каие - нет. Чем менее строгая модель согласованности, тем меньше гарантий она дает и тем больше вариантов истории операций считаются валидными.




---

### Источники:
1. link

### Ссылки:
1. [[Replication]]