---
date: 2022-05-28
tags:
    - scalability
---

# Partitioning

Партиционирование - это разбиение хранимых данных на части для обеспечения [[Scalability|масштабируемости]], [[Availability|доступности]] и поддерживаемости. Поддерживаемость достигается за счет того, что большой дата сет делится на более маленькие части, которые можно "обслуживать" независимо.

Интересную точку зрения выразил *Phil Delgyado* [4]: в случае [[Kafka design|Kafka]] каждая партиция обрабатывается одним консьюмером, значит все сообщения партиции придут в один и тот же консьюмер и это позволит эффективно [[Caching|кэшировать]] данные, необходимые для обработки сообщений с одним ключом.

## Логические и физические партиции

В начале работы системы данных мало и использовать для каждого шарда отдельный сервер нерационально. Поэтому выделяют *логические* партиции, с которыми работает приложение и которые уже по своим правилам мапятся на физические машины. Т.е. сначала все логические шарды могут находиться на одном сервере (*вертикальное партиционирование*), а с увеличением нагрузки они могут разделяться на несколько(*горизонтальное партиционирование* или **шардирование**). При этом распределение партиций может производится с учетом географии.

## Sharding key

Это признак, по которому принимается решение на какую партицию отправить запрос. Ключ должен быть таким, чтобы обеспечить возможность равномерного распределения данных(и соответственно обрабатываемых запросов) по партициям. Также важно, чтобы не приходилось делать крос-шардовых запросов, потому что они чаще всего дорогие.

Интересную точку зрения выразил *Phil Delgyado* [4]: в случае [[Kafka design|Kafka]] ключ *определяется* продьюсером, но *влияет* на работу консьюмера. При этом для разных консьюмеров могут быть предпочтительными разные ключи.

### Плохие варианты

1. Монотонно возрастающий ключ. Не дает равномерно распределить данные по шардам. Можно, например, обозначить для каждого шарда диапазон ключей (*bucket*), но т.к. ключ уходит в бесконечность последний bucket всегда будет становиться самым нагруженным. Потребуется изменять диапазоны и перераспределять данные между шардами, что дорого.
1. Ключ с низкой *кардинальностью*. Чем выше кардинальность ключа, тем больше возможных значений он может принимать, тем проще распределить равномерно большое количество данных по шардам. Низкая кадинальность например у кода региона РФ.

## Недостатки

Партиционирование и тем более шардирование вносит дополнительную сложность в инфраструктуру системы.

---

## Источники

1. [Mongo DB. Sharding](http://learnmongodbthehardway.com/schema/sharding/)
1. [Хабр. С чего начинается Elasticsearch](https://habr.com/ru/post/489924/)
1. [Sharding vs. partitioning: What’s the difference?](https://planetscale.com/learn/articles/sharding-vs-partitioning-whats-the-difference)
1. [Russian Association of Software Architects]((https://t.me/ru_arc_chat/41581))
1. [Russian Association of Software Architects]((https://t.me/ru_arc_chat/41582))

## Ссылки

1. [[RabbitMq vs Kafka]]
