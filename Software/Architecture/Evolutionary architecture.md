---
date: 2022-12-08
tags:
    - tag
---
# Evolutionary architecture

> To build an evolvable system, architects must think about how the system might evolve across all the important dimensions.

## Составляющие evolutionary architecture

### Architecture dimensions

> Before trying to build an evolutionary architecture, make sure developers can evolve the data as well (см. [[Evolutionary data]]).

An evolutionary architecture consists of three primary aspects: incremental change, fitness functions, and appropriate coupling.

### Incremental change

Требование incremental касаются изменений:

1. при разработке(*development*). Архитектура должна позволять вносить небольшие изменения
1. при поставке(*deployment*). Архитектура должна позволять выполнять небольшие поставки. Это возможность во многом обеспечивают практики [[Continious Delivery]]

### [[Fitness functions]]

Описывают целевые характеристики архитектуры. Держат архитектуру "в форме", *guide changes*, чтобы быстрота изменений(*incremental change*) не приводила к отклонению важных харакетристик от целевых показателей. *System-wide* ff позволяют сравнить  две архитектуры как статически(какие результаты показывают ff), так и с точки зрения как разные [[Architecture dimensions]] реагируют на определенные изменения.

### Appropriate coupling

см. [[Coupling]]

> Evolution is easier if developers have created a modular component system with well-defined integration points.

## Guidelines for building evolutionary architecture (Chapter 6)

1. [[Remove needless variability]]
1. [[Make decisions reversible]]
1. *Prefer evolvable over predictable*. Общий принцип, который призывает не расчитывать на умение предугадать будущее, а вместо этого делать инкрементальные изменения, получать обратную связь и главное быть готовым(процессно и технически) к изменениям по его итогам. По сути отражает идеи [[Agile]].
1. [[Last responsible moment]]. По сути связан с предыдущей рекомендацией. Вместо того, чтобы предсказывать будущее и уже сейчас принимать какое-то архитектурное решение, например выбирать идеальную СУБД или очередь, лучше выбрать исходя из тех требований, которые есть в данный момент, но не привязывать себя к конкретному выбору, а исопльзовать абстракцию. Абстракция позволит отложить момент принятия итогового решения, выбора конкретного инструмента. По сути и момента этого не будет вообще - будет поледовательность выборов в процессе эволюции архитектуры - *continuous architecture*.
1. [[Service template]]
1. *Build sacrificial architecture*. Быть готовым в какой-то момент, когда архитектура перестанет удовлетворять новый требованиям, отказаться от нее и переделать с учетом новых вводных. Классический пример - создание прототипа и потом после проверки гипотезы полный отказ от него, и создание системы с нуля. Авторы приводят также пример Twitter: изначально он был написан на Ruby on Rails и в какой-то момент перестал справляться с нагрузкой из-за роста популярности сервиса. Тогда было принято решение переписать backend на Java.
    * Возможность переписать один из кусочков системы, не меняя остальное, помогает достичь принцип *Last responsible moment*
    * То, что Twitter изначально использовал Ruby on Rails, а не Java - это не обязательно ошибка выбора языка или фреймворка. Возможно на первых этапах создания сервиса ключевой задачей была именно скорость выхода на рынок, чтобы занять пустующее место. Времени на овладение новым инструментами не было и возможно выбор был сделан исходя из текущих компетенций команды или простоты найма разработчиков. Это пример влияния различных [[Architecture drivers basics|architecture drivers]]
1. *Mitigate external change*. Необходимо построить процессы, чтобы полностью не зависеть от изменений в сторонних инструментах. С точки зрения независимости в коде нужно использовать принцип *last responsible moment*, но это далеко не все. Авторы предлагают дублировать важные зависимости на своей стороне и строить для их обновлений отдельный pipeline, который запускал бы все проверки прежде чем обновлять критичную библиотеку или фреймоврк. Это также должно защищать от случая, когда внешняя зависимость просто исчезает. Мы просто останемся работать с нашей копией и это в моменте не приведет к глобальной проблеме.
1. Updating libraries vs frameworks. Эти зависимости имеют разную природу и [[Coupling]] с кодом нашей системы. Использование фреймворка создает бОльший *coupling*, чем использование библиотеки, потому что библиотеки обычно предоставляют точечные функции-утилиты. Из-за разной природы подход к обновлению этих зависимостей тоже различается:
    * фреймворки обновлять **агрессивно**. Нужно не отставать от обновлений фреймворков, иначе обновление будет становится все более и более сложным, а значит и трудозатратным и будет откладываться дальше.
    * библиотеки обновлять **пассивно**. Потому что и coupling от них меньше, и отставание не так страшно.
1. *Version services internally*. Версионировать точки интеграции можно явно(*version numbering*), например номер версии в url'e, или неявно(*internal resolution*), когда логика обработки запроса сама должна понять с какой версие клиента она имеет дело. По возможности надо выбирать *internal resolution*, обеспечивая [[Compatibility]].
1. *Prefer [[Continuous Delivery]] to Snapshots*.

---

## Источники

1. [[Building evolutionary architectures book]]

## Ссылки

1. [[Architecture quantum]]#
