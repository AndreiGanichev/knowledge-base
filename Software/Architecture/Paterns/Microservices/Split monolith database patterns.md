---
date: 2025-11-20
---
# Split monolith database patterns

Допустим мы разделили логику монолита на разные микросервисы, но осталась общая БД, в которую пишут и читают эти микросервисы.

## Уходим от shared database

### Database view

View становится публичным контрактом сервиса. То, что это делается явно снижает [[Coupling]] этого решения, по сравнению с [[Shared database antipattern]]. Особенно полезны с точки зрения реализации могут быть materialized view. Паттерн целесообразно использовать только если нет планом дальнейшенго распиливания монолитной БД.
Но этот подход ограничен возможностями текущей СУБД(поддерживаются view или нет).

### Database wrapping service

Я вляется более предпочтительным по сравнению с Database View:

1. нет требований что внутренняя СУБД должна поддерживать функционал view
1. можно реализовать более сложное представление данных по сравнению с тем, что предоставляют СУБД при формировании view
1. сервис может обсулуживать и write запросы
1. скрывает хранилище от внешних сервисов и дает понять сервисам-потребителям, что они не владеют этими данными

Во многом этот паттерн - способ спрятать беспорядок текущей БД за API сервиса и по-хорошему должен стать промежуточным шагом к более фундаментальным изменениям в БД.

### Database-as-a-Service Interface

Это можно сказать развитие идеи Database view, но в этом случае выделяется целая отдельная БД для интеграции.
Достоинством является то, что теперь внутренняя база сервиса и интеграционная база не ограничены выбором одной и той же СУБД.

![Move from shared database](Images/Move%20from%20shared%20database.png)

## Разделяем shared database

Предыдущие паттерны помогали уменьшить coupling, но не давали реального разделения данных.

![Split shared database](Images/Split%20database.png)

## Aggregate exposing monolith

Отличия от *Database wrapping service*

1. формируетя вокруг агрегата
1. подходит только, если есть возможность изменять код монолита

В качестве API могуть быть эндпойнты или же публикуемые события. Паттерня является хорошим шагом на пути выделения отдельного микросервиса, потому что если мы отталкиваемся от агргата, то это как раз позволяет ограничить логику и данные, которые потом должны быть отделены.
Чтобы отделить данные нового микросервиса от монолитной БД, но при этом сохранить возможность **инкрементальных** и **откатываемых** изменений, например [[Strangler fig pattern]], надо рещить вопрос синхронизации данных.

При выборе решения для синхронизации важным является **допустимый период рассинхрона данных**. Плюс реализация сильно упрощается, если в каждый момент времени требуется синхронизация только в одном направлении, т.е. запросы на изменение идут либо в монолит, либо в микросервис, но не одновременно в оба места.

## Synchronize data in Application

Паттерн предполагает, что на стороне приложения при необходимости изменений будет производится обращения к обоим БД.

---

## Источники

1. [[Monolith to microservices book]]

## Ссылки

1. [[Migration from monolith]]
2. [[Shared database antipattern]]
