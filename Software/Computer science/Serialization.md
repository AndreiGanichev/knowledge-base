---
date: 2022-05-06
tags:
    - strings
---

## Определение

> In memory, data is kept in objects, structs, lists, arrays, hash tables, trees, and so on. These data structures are optimized for efficient access and manipulation by the CPU (typically using [[Pointer]]). [[Designing Data-Intensive Applications book]]. Chapter 4.


Чтобы это состояние сохранить на диск или передать по сети объекты должны быть представлены в виде последовательности битов. Этот процесс называется *serialization, encoding*. В этом случае указатели уже не могут использоваться и объект должен быть самодостаточным, т.е. содержать всю необходимую информацию в себе. Процесс восстановления объектов(при чтении с диска или из сети) - *deserialization, decoding*. 

Различают следующие способы сериализации:
1. бинарная
1. текстовая

## Бинарная

*Примеры:* Thrift, Protobuf, Avro, драйверы для общения с СУБД, например JDBC

Бинарная сериализация чаще всего более эффективная с точки зрения итогового объема данных. Это достигается за счет использования схемы, которая позволяет не передавать имена полей в каждом документе, а либо ориентироваться на их идентификаторы(теги), либо на порядок. Схема также является важнейшим инструментом обеспечения [[Compatibility]].

### Достоинства
1. оптимальная с точки зрения объема сериализованных данных
1. поддержка bynary strings - последовательность бит, с помощью которых можно передать любые данные, например файлы.
1. схема обеспечивает валидность и явно документирует содержимое
1. из схемы можно генерировать клиентский код на различных языках

### Protocol buffers

Интересной особенностью схемы является отсутствие списка как типа данных. Вместо этого для поля применяется ключевое слово ```repeated```, которое обозначает, что в документе может быть от нуля до нескольких значений определенного типа. Например ```repeated string names``` по сути моделирует массив строк.

Замена ```repeated string names``` на ```optional string names``` удовлетворяет прямой и обратной совместимости. В отсутствие опционального поля будет эквивалентно пустому массиву.

### Avro

Среди форматов бинарной сериализации отличается Avro. Он предполагает наличие схемы на запись и на чтение. Тулинг Avro при чтении сообщения анализирует схему для записи, которая использовалась при создании сообщения и создает маппинг в текущую схему для чтения, которая используется приложением. Т.о. схемы на чтения и запись не должны быть одинаковыми, они должны быть совместимыми, чтобы можно было сделать маппинг.

## Текстовая

Текстовая сериализация заключается в преобразовании объекта в строку и потом уже эта **строка** может быть сохранена на диск или передана по сети. Для XML, JSON также можно создавать схемы, но их функционал довольно монструозный и поэтому их сложно использовать. В итоге они не получили широкого распространения.

Бинарные строки можно передавать, но предварительно их нужно закодировать в [base64](https://en.wikipedia.org/wiki/Base64). Недостатком такого способа является увеличение закодированного объема относительно исходного на 33%.

### Достоинства
1. человекочитаемый формат
1. у JSON встроенная поддержка в браузерах
1. XML и JSON схемы являются мощными инструментами описания. Правда их сложность становится препятствием для повсеместного использования.

### Недостатки
1. неэффективная передача бинарных строк
1. избыточность -> большой объем сериализованных данных
1. JSON не различает целые числа и числа с плавающей точкой, не поддерживает задания точности. [[Designing Data-Intensive Applications book]]. Chapter 4. JSON, XML, and Binary Variants.


Существуют также **бинарная сериализация для JSON**(MessagePack, BSON), нечто среднее между текстовым и бинарным форматом. В отличие от бинарной сериализации не меняют сути передачи JSON - в каждом документе передаются все имена полей. Поэтому экономия объема получается не такой значительной. При этом теряется читаемость.

## Сериализация сложных объектов

Сложные объекты можно в итоге разложить до примитивных типов: целые числа, числа с плавающей точкой, строки, для которых разработано двоичное представление. И если с типами фиксированной длины(_int16_, _int32_) все более или менее понятно (понятно сколько они будут занимать байтов), то с типами переменной длины все несколько сложнее.

### Сериализация строк

Например, для строк есть два разных способа сериализации:

1. _null-terminated strings_ или _ASCIZ_
   Строки в таком формате всегда окончиваются нулем. Т.о. для чтения нужно просто последовательно читать байты пока не дойдешь до нуля. Чтобы вычислить длину строки нужно все равно проходиться по ней полностью и считать байты - O(n)

1. _Pascal strings_
   Строка представлена уже как структура, которая содержит два поля примитивных типов: сама строка и отдельно ее длина. Чтобы вычислить длину строки, просто читаем нужное поле в структуре - O(1). Но длина самой строки ограничена типов выбранным для значения длины в структуре.

```
String
{
    size    uint_16
    data    byte[size]
}
```

*Pascal string* - это пример как для получения чего-то более сложного используется композиция простых элементов, в данном случае примитивных типов.

---

### Источники:
1. [[Database Internals book]]. Chapter 3. File formats
2. [Stackoverflow answer](https://stackoverflow.com/a/3316779/6194366)

### Ссылки
1. Джоэл Спольски. Джоэл о программировании. Символ-Плюс, 2006. Глава 2. Обращаясь к основам.