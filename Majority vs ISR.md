---
date: 2022-01-01
tags:
    - kafka
    - zookeeper
    - ISR
    - quorum
---

### Проблема

При репликации в распределенной системе возникает необходимость застраховаться от падения лидера. Для того, чтобы с одной стороны не потерять данные при падении лидера, с другой - не реплицировать синхронно на все ноды, используются пересекающиеся кворумы(обычно берется большинство нод): кворум на синхронную репликацию и кворум при выборе нового лидера. В итоге гарантируется пересечение этих кворумов и хотя бы одна нода будет содержать максимально актуальные данные после падения лидера.  

### Majority quorum

Недостатком *majority quorum* является избыточность кластера. Чтобы застраховаться от падения всего одной ноды, нужно иметь кластер из 3 нод. От падения двух нод - кластер из 5ти нод. 

### ISR
Альтернативой majority выступает подход, используемы в Kafka. Чтобы сообщение считалось committed оно должно быть реплицировано на все реплики из списка *in-sync replicas(ISR)*. 
При падении лидера новый может быть выбран только из ISR. При записи лидер для комита должен записать на все ISR, но при этом для работы достаточно по сути всего одной ноды из ISR.


### Сравнение
Т.о. кластер из *f+1* нод переживает *f* падений. То же значение падений при использовании majority обеспечивается общим кол-во нод *2f+1*. Топик можно скофигурировать минимальным кол-вом ISR, при которой запись была бы возможной. Т.е. если продьюсер публикует сообщение с настройкой *all* (т.е. сообщение будет считаться закомиченным если оно реплицируется на все ISR), то публикация будет успешной, если в ISR не меньше сконфигурированного минимума. Т.о. эта настройка приближает ISR к majority quorum. Тут вступает в дело компромисс *durability*(устанавливаем побольше минимальный объем ISR, чтобы не потерять данные) vs *availability*(работаем до последней рабочей  in-sync реплики).

Отличие ISR от majority quorum в том, что использование ISR отвязывает требуемое кол-во ответов, чтобы запись считалась committed, от общего кол-ва реплик. Плюс в этом подходе не достаточно любого большинства, а нужно дождаться определенного набора реплик. Это потенциально увеличивает *latency*, потому что запись может быть долгой из-за медленных реплик в ISR или в случае падения нужно дождаться его опознавания и исключения этой реплики из ISR.

Поэтому majority стоит использовать для наиболее критичных данных, например метаданных кластера. Именно так и поступает ZooKeeper, когда реплицирует свои данные.

## Источники

1. [Distributed Consensus Reloaded: Apache ZooKeeper and Replication in Apache Kafka](https://www.confluent.io/blog/distributed-consensus-reloaded-apache-zookeeper-and-replication-in-kafka)

### Ссылки:

1. [[Cluster metadata replication]]